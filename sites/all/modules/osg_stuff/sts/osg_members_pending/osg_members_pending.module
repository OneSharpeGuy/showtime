<?php

/**
* @file osg_members_pending.module
* TODO: Enter file description here.
*/

/**
* Implements hook_menu()
*
* Alter a menu router item right after it has been retrieved from the database or cache.
*
* This hook is invoked by menu_get_item() and allows for run-time alteration of router
* information (page_callback, title, and so on) before it is translated and checked for
* access. The passed-in $router_item is statically cached for the current request, so this
* hook is only invoked once for any router item that is retrieved via menu_get_item().
*
* Usually, modules will only want to inspect the router item and conditionally
* perform other actions (such as preparing a state for the current request).
* Note that this hook is invoked for any router item that is retrieved by
* menu_get_item(), which may or may not be called on the path itself, so implementations
* should check the $path parameter if the alteration should fire for the current request
* only.
*
* @param $router_item
*   The menu router item for $path.
* @param $path
*   The originally passed path, for which $router_item is responsible.
* @param $original_map
*   The path argument map, as contained in $path.
*
* @see menu_get_item()
*/
function osg_members_pending_menu()
{
  $items['admin/config/osg/singout/osg_members_pending'] = array(
    'title'           => 'Text Me Config',
    'page callback'   => 'drupal_get_form',
    'page arguments'             => array('osg_members_pending_form'),
    'access arguments' => array('configure texting'),
    // 'type'            => MENU_SUGGESTED_ITEM,
  );
  return $items;

}

/**
* Implements hook_permission()
*
* Define user permissions.
*
* This hook can supply permissions that the module defines, so that they
* can be selected on the user permissions page and used to grant or restrict
* access to actions the module performs.
*
* Permissions are checked using user_access().
*
* For a detailed usage example, see page_example.module.
*
* @return
*   An array whose keys are permission names and whose corresponding values
*   are arrays containing the following key-value pairs:
*   - title: The human-readable name of the permission, to be shown on the
*     permission administration page. This should be wrapped in the t()
*     function so it can be translated.
*   - description: (optional) A description of what the permission does. This
*     should be wrapped in the t() function so it can be translated.
*   - restrict access: (optional) A boolean which can be set to TRUE to
*     indicate that site administrators should restrict access to this
*     permission to trusted users. This should be used for permissions that
*     have inherent security risks across a variety of potential use cases
*     (for example, the "administer filters" and "bypass node access"
*     permissions provided by Drupal core). When set to TRUE, a standard
*     warning message defined in user_admin_permissions() and output via
*     theme_user_permission_description() will be associated with the
*     permission and displayed with it on the permission administration page.
*     Defaults to FALSE.
*   - warning: (optional) A translated warning message to display for this
*     permission on the permission administration page. This warning overrides
*     the automatic warning generated by 'restrict access' being set to TRUE.
*     This should rarely be used, since it is important for all permissions to
*     have a clear, consistent security warning that is the same across the
*     site. Use the 'description' key instead to provide any information that
*     is specific to the permission you are defining.
*
* @see theme_user_permission_description()
*/
function osg_members_pending_permission()
{
  return array('configure texting' => array(
      'title'      => t('Configure SMS Texting'),
      'description'=> t('Set parameters for SMS messaging.'),
    ),);
}

/**
* Implements hook_form()
*
* Display a node editing form.
*
* This hook, implemented by node modules, is called to retrieve the form
* that is displayed to create or edit a node. This form is displayed at path
* node/add/[node type] or node/[node ID]/edit.
*
* The submit and preview buttons, administrative and display controls, and
* sections added by other modules (such as path settings, menu settings,
* comment settings, and fields managed by the Field UI module) are
* displayed automatically by the node module. This hook just needs to
* return the node title and form editing fields specific to the node type.
*
* @param $node
*   The node being added or edited.
* @param $form_state
*   The form state array.
*
* @return
*   An array containing the title and any custom form elements to be displayed
*   in the node editing form.
*
* @ingroup node_api_hooks
*/
function osg_members_pending_form($node, & $form_state)
{
  $form['osg_members_pending_phone_number'] = array(
    '#type'         => 'textfield',
    '#title'        => t('Phone Number'),
    '#description'  => t('Phone number for Text Messaging.'),
    '#default_value'=> variable_get('osg_members_pending_phone_number',
      '5557779311'),

  );
  $carriers = array(
    '{n}@teleflip.com'           => 'Teleflip',
    '{n}@message.alltel.com'     => 'Alltel',
    '{n}@paging.acswireless.com' => 'Ameritech',
    '{n}@txt.att.net'            => 'ATT Wireless',
    '{n}@bellsouth.cl'           => 'Bellsouth',
    '{n}@myboostmobile.com'      => 'Boost',
    '{n}@mobile.celloneusa.com'  => 'Orange',
    '{n}@mms.uscc.net'           => 'CellularOne MMS',
    '1{n}@mobile.mycingular.com' => 'Cingular',
    '{n}@sms.edgewireless.com'   => 'Edge Wireless',
    '{n}@messaging.sprintpcs.com'=> 'Sprint',
    '{n}@tmomail.net'            => 'T-Mobile',
    '{n}@mymetropcs.com'         => 'Metro PCS',
    '{n}@messaging.nextel.com'   => 'Nextel',
    '{n}@qwestmp.com'            => 'Qwest',
    '{n}@pcs.rogers.com'         => 'Rogers Wireless',
    '{n}@msg.telus.com'          => 'Telus Mobility',
    '{n}@email.uscc.net'         => 'US Cellular',
    '{n}@vtext.com'              => 'Verizon',
    '{n}@vmobl.com'              => 'Virgin Mobile',
  );
  $default = array_flip($carriers);
  $form['osg_members_pending_carrier'] = array(
    '#type'         => 'select',
    '#title'        => t('Carrier'),
    '#description'  => t('Select cellular carrier.'),
    '#default_value'=> variable_get('osg_members_pending_carrier', $default['Sprint']),
    '#options'      => $carriers,
  );
  $cron_safe_threshold = variable_get('cron_safe_threshold', 60);
  $interval            = variable_get('osg_members_pending_interval', 60 * 60);

  if ($cron_safe_threshold == 0) {
    $blurb = "Cron is not running.";
  }
  else {
    $next_cron_time = variable_get('cron_last', time()) + $cron_safe_threshold;

    $show_time      = variable_get('osg_members_pending_next_execution', time());
    if ($show_time < $next_cron_time) {
      $show_time = $next_cron_time;
    }
    $elap = $show_time - time();
    $blurb= 'Cron job will execute at ' . osg_api_get_local_date($show_time);
    if ($elap > 0) {
      $blurb = $blurb . ' or in ' . $elap . ' seconds.';
    }
    else {
      $blurb = 'Will execute the next time cron runs.';
    }
  }
  $form['exection_time'] = array(
    '#type'  => 'markup',
    '#markup'=> "<p>$blurb</p>",
  );

  $options = array_merge(array(0=> t('Never')), osg_api_time_selection(null, true));

  //$options = array_merge(array(0 => t('Never')),$options);
  //debug($options);
  $form['osg_members_pending_interval'] = array(
    '#type'         => 'select',
    '#title'        => t('Cron interval'),
    '#description'  => t('Time after which osg_members_pending_cron will respond to a processing request.'),
    '#default_value'=> $interval,
    '#options'      => $options,
    '#disabled'     => ($cron_safe_threshold == 0),
  );
  $form['osg_members_pending_send_now'] = array(
    '#type'  => 'submit',
    '#value' => t('Send Notification Now'),
    '#weight'=> 50,
    '#submit' => array('osg_members_pending_cron'),
  );
  return system_settings_form($form);
}

/**
* Implements hook_help()
*
* Provide online user help.
*
* By implementing hook_help(), a module can make documentation available to
* the user for the module as a whole, or for specific paths.  Help for
* developers should usually be provided via function header comments in the
* code, or in special API example files.
*
* For a detailed usage example, see page_example.module.
*
* @param $path
*   The router menu path, as defined in hook_menu(), for the help that is
*   being requested; e.g., 'admin/people' or 'user/register'.  If the router
*   path includes a wildcard, then this will appear in $path as %, even if it
*   is a named %autoloader wildcard in the hook_menu() implementation; for
*   example, node pages would have $path equal to 'node/%' or 'node/%/view'.
*   To provide a help page for a whole module with a listing on admin/help,
*   your hook implementation should match a path with a special descriptor
*   after a "#" sign:
*     'admin/help#modulename'
*       The main module help text, displayed on the admin/help/modulename
*       page and linked to from the admin/help page.
* @param $arg
*   An array that corresponds to the return value of the arg() function, for
*   modules that want to provide help that is specific to certain values
*   of wildcards in $path. For example, you could provide help for the path
*   'user/1' by looking for the path 'user/%' and $arg[1] == '1'. This given
*   array should always be used rather than directly invoking arg(), because
*   your hook implementation may be called for other purposes besides building
*   the current page's help. Note that depending on which module is invoking
*   hook_help, $arg may contain only empty strings. Regardless, $arg[0] to
*   $arg[11] will always be set.
*
* @return
*   A localized string containing the help text.
*/
function osg_members_pending_help($path, $arg)
{

}

function osg_members_pending_cron()
{
  $interval = variable_get('osg_members_pending_interval', 300);
  if ((!is_null($interval)) && is_numeric($interval) && ($interval > 0)) {
    drupal_set_message('osg_members_pending_cron');
    // We usually don't want to act every time cron runs (which could be every
    // minute) so keep a time for the next run in a variable.
    //variable_del('osg_members_pending_next_execution');
    $next_exec = (int)variable_get('osg_members_pending_next_execution', 0);
    if (time() >= $next_exec) {

      /*
      SELECT *
      FROM role r
      INNER JOIN users_roles u ON u.rid=r.rid AND r.`name`='pending memeber'
      LEFT JOIN osg_users o ON o.uid=u.uid
      WHERE o.uid IS NULL
      */
      $query          = db_select('role','r');
      $query->fields('r');
      $query->join('users_roles','u','u.rid=r.rid');
      $query->leftJoin('osg_users','o','o.uid=u.uid');
      $query->condition('r.name', 'pending member');
      $query->isNull('o.uid');
      $result         = $query->execute();
      $number_of_rows = $result->rowCount();
      if ($number_of_rows) {
        osg_singout_support_reset_table_osg_user();
      }


      /*
      SELECT s.user_name,s.first_name,s.last_name
      FROM users_roles ur
      INNER JOIN role r ON ur.rid=r.rid
      INNER JOIN osg_users s ON ur.uid=s.uid
      WHERE r.name='pending member'
      */
      $query = db_select('users_roles', 'u');
      $query->join('role', 'r', 'u.rid=r.rid');
      $query->join('osg_users', 's', 'u.uid=s.uid');
      $query->join('users', 'e', 'e.uid=s.uid');
      $query->condition('r.name', 'pending member');
      $query->condition('e.status', 1);
      $query->fields('s', array('user_name','first_name','last_name'));
      //debug((string)$query);
      $result         = $query->execute();
      $number_of_rows = $result->rowCount();
      if ($number_of_rows) {
        while ($record = $result->fetchAssoc()) {
          $msg = 'User ' . $record['user_name'] . " (" . $record['first_name'] . ' ' . $record['last_name'] .
          ') has created an account on ' . $_SERVER['HTTP_HOST'] . " and awaits approval.";

          osg_members_pending_send_text($msg);
        }
      }
    }
  }
}

/*
* Implements hook_cron_queue_info().
*/
function osg_members_pending_cron_queue_info()
{
  $queues['send_emails'] = array(
    'worker callback'=> 'osg_members_pending_send_text',
    'time'           => 120,
  );
  return $queues;
}

function osg_members_pending_send_text($body)
{
  /*
  $result = db_update('node')
  ->fields(array('title'=> $data->title . 'abc'))
  ->condition('nid', $data->nid)
  ->execute();
  */


  $message['body'] = explode("\n", $body);
  //drupal_mail($module,$key,$to,$language,$params = array(),$from = NULL,$send = TRUE)
  $sender   = variable_get('site_mail');
  $carrier  = variable_get('osg_members_pending_carrier');
  $phone_no = variable_get('osg_members_pending_phone_number', 5555555555);
  //debug(array('phone_no'=>$phone_no,'$carrier'=>$carrier    ));
  $recipient= str_replace('{n}', $phone_no, $carrier);
  //debug($recipient,'recipeint');
  drupal_mail('osg_members_pending', 'osg_members_pending_send_text', $recipient,
    language_default(), $message, $sender, true);

}


function osg_members_pending_mail($key, & $message, $params)
{
  $options = array('langcode'=> $message['language']->language,                                                             );
  /*  debug($key, '$key');
  debug($params, '$params');*/
  switch ($key) {

    case 'osg_members_pending_send_text':
    $message['body'] = explode("\n", check_plain(implode("\n", $params['body'])));

    //$message['subject'] = check_plain($params['subject']);
    //$message['headers']['Content - Type'] = $params['headers']['Content - Type'] ;
    break;

  }
  //debug($message,"MESSAGE");

}
/**
* Allow user to directly execute cron, optionally forcing it.
*/
function osg_members_pending_form_submit($form, & $form_state)
{

  if (drupal_cron_run()) {
    drupal_set_message(t('Cron ran successfully.'));
  }
  else {
    drupal_set_message(t('Cron run failed.'), 'error');
  }
}
